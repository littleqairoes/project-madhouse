<!-- Bower Components Dependencies -->
<link rel="import" href="../../bower_components/polymer/polymer-element.html">

<!-- Project Components Dependencies -->

<!-- Element Definition -->
<script>
  (function() {
    class ProjectBaseLocation extends Polymer.Element {
      static get is() { return 'project-base-location'; }

      constructor() {
        super();
        this.__boundHashChanged = this._hashChanged.bind(this);
        this.__boundUrlChanged = this._urlChanged.bind(this);
        this.__boundGlobalOnClick = this._globalOnClick.bind(this);
      }

      connectedCallback() {
        super.connectedCallback();
        window.addEventListener('hashchange', this.__boundHashChanged);
        window.addEventListener('location-changed', this.__boundUrlChanged);
        window.addEventListener('popstate', this.__boundUrlChanged);
        window.document.body.addEventListener('click', this.__boundGlobalOnClick);

        // Give a 200ms grace period to make initial redirects without any
        // additions to the user's history.
        this._lastChangedAt = window.performance.now() - (this.dwellTime - 200)
        this._initialized = true;
        this._urlChanged();
      }

      disconnectedCallback() {
        window.removeEventListener('hashchange', this.__boundHashChanged);
        window.removeEventListener('location-changed', this.__boundUrlChanged);
        window.removeEventListener('popstate', this.__boundUrlChanged);
        window.document.body.removeEventListener('click', this.__boundGlobalOnClick);
        this._initialized = false;
      }

      static get properties() {
        return {
          /**
           * The pathname component of the URL.
           */
          path: {
            type: String,
            notify: true,
            value: function() {
              return window.decodeURIComponent(window.location.pathname);
            }
          },
          /**
           * The query string portion of the URL.
           */
          query: {
            type: String,
            notify: true,
            value: function() {
              return window.location.search.slice(1);
            }
          },
          /**
           * The hash component of the URL.
           */
          hash: {
            type: String,
            notify: true,
            value: function() {
              return window.decodeURIComponent(window.location.hash.slice(1));
            }
          },
          /**
           * If the user was on a URL for less than `dwellTime` milliseconds, it
           * won't be added to the browser's history, but instead will be replaced
           * by the next entry.
           *
           * This is to prevent large numbers of entries from clogging up the user's
           * browser history. Disable by setting to a negative number.
           */
          dwellTime: {
            type: Number,
            value: 2000
          },
          /**
           * A regexp that defines the set of URLs that should be considered part
           * of this web app.
           *
           * Clicking on a link that matches this regex won't result in a full page
           * navigation, but will instead just update the URL state in place.
           *
           * This regexp is given everything after the origin in an absolute
           * URL. So to match just URLs that start with /search/ do:
           *     url-space-regex="^/search/"
           *
           * @type {string|RegExp}
           */
          urlSpaceRegex: {
            type: String,
            value: ''
          },
          /**
           * urlSpaceRegex, but coerced into a regexp.
           *
           * @type {RegExp}
           */
          _urlSpaceRegExp: {
            computed: '_makeRegExp(urlSpaceRegex)'
          },
          _lastChangedAt: {
            type: Number
          },
          _initialized: {
            type: Boolean,
            value: false
          }
        };
      }

      static get observers() {
        return [
          '_updateUrl(path, query, hash)'
        ]
      }

      // Computed functions
      //---------------------------------------------------------------
      _makeRegExp(urlSpaceRegex) {
        return RegExp(urlSpaceRegex);
      }

      // Observer functions
      //---------------------------------------------------------------

      _updateUrl() {
        if (this._dontUpdateUrl || !this._initialized) {
          return;
        }
        if (this.path === window.decodeURIComponent(window.location.pathname) &&
            this.query === window.location.search.substring(1) &&
            this.hash === window.decodeURIComponent(window.location.hash.substring(1))) {
          // Nothing to do, the current URL is a representation of our properties.
          return;
        }
        var newUrl = this._getUrl();
        // Need to use a full URL in case the containing page has a base URI.
        var fullNewUrl = new URL(newUrl, window.location.protocol + '//' + window.location.host).href;
        var now = window.performance.now();
        var shouldReplace = this._lastChangedAt + this.dwellTime > now;
        this._lastChangedAt = now;
        if (shouldReplace) {
          window.history.replaceState({}, '', fullNewUrl);
        } else {
          window.history.pushState({}, '', fullNewUrl);
        }

        window.dispatchEvent(new CustomEvent('location-changed'));
      }

      _urlChanged() {
        // We want to extract all info out of the updated URL before we
        // try to write anything back into it.
        //
        // i.e. without _dontUpdateUrl we'd overwrite the new path with the old
        // one when we set this.hash. Likewise for query.
        this._dontUpdateUrl = true;
        this._hashChanged();
        this.path = window.decodeURIComponent(window.location.pathname);
        this.query = window.location.search.substring(1);
        this._dontUpdateUrl = false;
        this._updateUrl();
      }

      _getUrl() {
        var partiallyEncodedPath = window.encodeURI(this.path).replace(/\#/g, '%23').replace(/\?/g, '%3F');
        var partiallyEncodedQuery = '';
        if (this.query) {
          partiallyEncodedQuery = '?' + this.query.replace(/\#/g, '%23');
        }
        var partiallyEncodedHash = '';
        if (this.hash) {
          partiallyEncodedHash = '#' + window.encodeURI(this.hash);
        }
        return (partiallyEncodedPath + partiallyEncodedQuery + partiallyEncodedHash);
      }

      _globalOnClick(event) {
        // If another event handler has stopped this event then there's nothing
        // for us to do. This can happen e.g. when there are multiple
        // iron-location elements in a page.
        if (event.defaultPrevented) {
          return;
        }
        var href = this._getSameOriginLinkHref(event);
        if (!href) {
          return;
        }
        event.preventDefault();

        // If the navigation is to the current page we shouldn't add a history
        // entry or fire a change event.
        if (href === window.location.href) {
          return;
        }
        window.history.pushState({}, '', href);
        window.dispatchEvent(new CustomEvent('location-changed'));
      }


      _hashChanged() {
        this.hash = window.decodeURIComponent(window.location.hash.substring(1));
      }

      _getSameOriginLinkHref(event) {
        // We only care about left-clicks.
        if (event.button !== 0) {
          return null;
        }

        // We don't want modified clicks, where the intent is to open the page
        // in a new tab.
        if (event.metaKey || event.ctrlKey) {
          return null;
        }
        var eventPath = Polymer.dom(event).path;
        var anchor = null;
        for (var i = 0; i < eventPath.length; i++) {
          var element = eventPath[i];
          if (element.tagName === 'A' && element.href) {
            anchor = element;
            break;
          }
        }

        // If there's no link there's nothing to do.
        if (!anchor) {
          return null;
        }

        // Target blank is a new tab, don't intercept.
        if (anchor.target === '_blank') {
          return null;
        }

        // If the link is for an existing parent frame, don't intercept.
        if ((anchor.target === '_top' ||
            anchor.target === '_parent') &&
            window.top !== window) {
          return null;
        }
        var href = anchor.href;

        // It only makes sense for us to intercept same-origin navigations.
        // pushState/replaceState don't work with cross-origin links.
        var url;
        if (window.document.baseURI != null) {
          url = new URL(href, /** @type {string} */(window.document.baseURI));
        } else {
          url = new URL(href);
        }
        var origin;

        // IE Polyfill
        if (window.location.origin) {
          origin = window.location.origin;
        } else {
          origin = window.location.protocol + '//' + window.location.hostname;
          if (window.location.port) {
            origin += ':' + window.location.port;
          }
        }
        if (url.origin !== origin) {
          return null;
        }
        var normalizedHref = url.pathname + url.search + url.hash;

        // If we've been configured not to handle this url... don't handle it!
        if (this._urlSpaceRegExp && !this._urlSpaceRegExp.test(normalizedHref)) {
          return null;
        }
        // Need to use a full URL in case the containing page has a base URI.
        var fullNormalizedHref = new URL(normalizedHref, window.location.href).href;
        return fullNormalizedHref;
      }
    }

    window.customElements.define(ProjectBaseLocation.is, ProjectBaseLocation);
  })();
</script>

