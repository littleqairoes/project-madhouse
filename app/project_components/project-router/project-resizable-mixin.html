<script>
  (function() {

    // expose BC settings.
    window.Polymer = window.Polymer || {};
    var settings = window.Polymer.Settings || {};
    settings.useShadow = !(window.ShadyDOM);
    settings.useNativeCSSProperties =
      Boolean(!window.ShadyCSS || window.ShadyCSS.nativeCss);
    settings.useNativeCustomElements =
      !(window.customElements.polyfillWrapFlushCallback);
    window.Polymer.Settings = settings;

    window.Mixins = window.Mixins || {};
    window.Mixins.Resizable = window.Mixins.Resizable || function(superClass) {
      return class extends superClass {

        constructor() {
          super();
          // We don't really need property effects on these, and also we want them
          // to be created before the `_parentResizable` observer fires:
          this._interestedResizables = [];
          this.__boundNotifyResize = this.notifyResize.bind(this);
          this.__boundOnRequestResizeNotifications = this._onRequestResizeNotifications.bind(this);
          this.__boundOnDescendantResize = this._onDescendantResize.bind(this);

        }

        connectedCallback() {
          super.connectedCallback();
          this.addEventListener('iron-request-resize-notifications', this.__boundOnRequestResizeNotifications)
          this.dispatchEvent(new CustomEvent('iron-request-resize-notifications', {
            bubbles: true,
            cancelable: true
          }))
          // this._onRequestResizeNotifications();

          if (!this._parentResizable) {
            window.addEventListener('resize', this.__boundNotifyResize);
            this.notifyResize();
          }

        }

        disconnectedCallback() {
          super.disconnectedCallback();
          this.removeEventListener('iron-request-resize-notifications', this.__boundOnRequestResizeNotifications);
          if (this._parentResizable) {
            this._parentResizable.stopResizeNotificationsFor(this);
          } else {
            window.removeEventListener('resize', this._boundNotifyResize);
          }
          this._parentResizable = null;
        }

        static get properties() {
          return {
            /**
             * The closest ancestor element that implements `IronResizableBehavior`.
             */
            _parentResizable: {
              type: Object,
              observer: '_parentResizableChanged'
            },
            /**
             * True if this element is currently notifying its descedant elements of
             * resize.
             */
            _notifyingDescendant: {
              type: Boolean,
              value: false
            }
          };
        }

        /**
         * Can be called to manually notify a resizable and its descendant
         * resizables of a resize change.
         */
        notifyResize() {
          if (!this.isAttached) {
            return;
          }
          this._interestedResizables.forEach(function(resizable) {
            if (this.resizerShouldNotify(resizable)) {
              this._notifyDescendant(resizable);
            }
          }, this);
          this._fireResize();
        }

        /**
         * Used to assign the closest resizable ancestor to this resizable
         * if the ancestor detects a request for notifications.
         */
        assignParentResizable(parentResizable) {
          this._parentResizable = parentResizable;
        }

        /**
         * Used to remove a resizable descendant from the list of descendants
         * that should be notified of a resize change.
         */
        stopResizeNotificationsFor(target) {
          var index = this._interestedResizables.indexOf(target);
          if (index > -1) {
            this._interestedResizables.splice(index, 1);
            target.removeEventListener('iron-resize', this.__boundOnDescendantResize);
            // this.unlisten(target, 'iron-resize', '_onDescendantIronResize');
          }
        }

        /**
         * This method can be overridden to filter nested elements that should or
         * should not be notified by the current element. Return true if an element
         * should be notified, or false if it should not be notified.
         *
         * @param {HTMLElement} element A candidate descendant element that
         * implements `IronResizableBehavior`.
         * @return {boolean} True if the `element` should be notified of resize.
         */
        resizerShouldNotify(element) { return true; }

        _onDescendantResize(event) {
          if (this._notifyingDescendant) {
            event.stopPropagation();
            return;
          }
          // NOTE(cdata): In ShadowDOM, event retargetting makes echoing of the
          // otherwise non-bubbling event "just work." We do it manually here for
          // the case where Polymer is not using shadow roots for whatever reason:
          if (!window.Polymer.Settings.useShadow) {
            this._fireResize();
          }
        }

        _fireResize() {
          this.dispatchEvent(new CustomEvent('iron-event', {
            bubbles: false
          }));
        }

        _onRequestResizeNotifications(event) {
          var target = event.path ? event.path[0] : event.target;
          if (target === this) {
            return;
          }
          if (this._interestedResizables.indexOf(target) === -1) {
            this._interestedResizables.push(target);
            target.addEventListener('iron-resize', this.__boundOnDescendantResize);
            // this.listen(target, 'iron-resize', '_onDescendantIronResize');
          }
          target.assignParentResizable(this);
          this._notifyDescendant(target);
          event.stopPropagation();
        }

        _parentResizableChanged(parentResizable) {
          if (parentResizable) {
            window.removeEventListener('resize', this._boundNotifyResize);
          }
        }

        _notifyDescendant(descendant) {
          // NOTE(cdata): In IE10, attached is fired on children first, so it's
          // important not to notify them if the parent is not attached yet (or
          // else they will get redundantly notified when the parent attaches).
          if (!this.isAttached) {
            return;
          }
          this._notifyingDescendant = true;
          descendant.notifyResize();
          this._notifyingDescendant = false;
        }
      }
    }
  })();
</script>
